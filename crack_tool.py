# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import cracktools as ct
from layout import Ui_MainWindow
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtCore import Qt
import skimage
import numpy as np
import cv2
import matplotlib.pyplot as plt
import json
import os
from skimage.segmentation import mark_boundaries
import os
from PyQt5.QtWidgets import QListWidgetItem, QFileDialog

from PyQt5.QtWidgets import QMessageBox
def error():
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Critical)
    msg.setText("Error")
    msg.setWindowTitle("Error")
    msg.exec_()
    
class CrackToolsApplication(Ui_MainWindow):
    def setupUi(self,MainWindow):
        super().setupUi(MainWindow)
        self.MainWindow = MainWindow
        self.SelectFolderButton.clicked.connect(self.select_folder)
        self.PreviousImageButton.clicked.connect(self.previous_image)
        self.NextImageButton.clicked.connect(self.next_image)
        self.draw_box_button.clicked.connect(self.draw_box)
        self.save_b_button.clicked.connect(self.save_box)
        self.clear_boxes_button.clicked.connect(self.clear_boxes)  
        self.clear_segmentation_button.clicked.connect(self.clear_segmentation) 
        self.files_list.itemSelectionChanged.connect(self.name_selected)

        self.select_points_button.clicked.connect(self.select_end_points)
        self.update_image_crop_button.clicked.connect(self.update_image_crop)
        self.wavelet_button.clicked.connect(self.check_wavelet)
        self.middle_point_button.clicked.connect(self.select_middle_point)
        self.middpoint_update_button.clicked.connect(self.update_midpoint_image)
        self.update_os_button.clicked.connect(self.update_os)
        self.show_os_button.clicked.connect(self.show_os)
        self.update_cost_button.clicked.connect(self.update_cost)
        self.midline_track_button.clicked.connect(self.midline_tracking)
        self.update_track_display_button.clicked.connect(self.update_track_display)
        self.track_full_screen_button.clicked.connect(self.track_full_screen)
        self.edge_mask_button.clicked.connect(self.edge_mask)
        self.edge_tracks_button.clicked.connect(self.edge_tracking)
        self.edge_tracks_full_screen_button.clicked.connect(self.edge_tracks_full_screen)
        self.save_current_segment_button.clicked.connect(self.save_current_segment)
        self.draw_segment_button.clicked.connect(self.draw_segment)
        self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)

        # self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        # self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)
        self.n = -1
        self.saved = False


        # self.select_points_button.setStyleSheet("background-color : red")
        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.draw_segment_button.setStyleSheet("background-color : red")
        self.show_os_button.setStyleSheet("background-color : red")

        # self.draw_segment_button.setStyleSheet("background-color : red")
####################### Select Image Tab ########################################
    def select_folder(self):
        try:
            #dir = self.folder_line_edit.text().replace(" \ ", "/" )
            dir = str(
                QFileDialog.getExistingDirectory(None, "Select Directory"))
            filenames = ct.tools.get_files(folder = dir,formats = ['jpg','png', 'tiff'],basename = False)
            self.image_names = filenames
            for filename in self.image_names:
                self.files_list.addItem(os.path.basename(filename))
            self.n = 0
            self.change_image()
        except Exception as e:
            print(e)
            error()

    def name_selected(self):
        self.n = self.files_list.currentRow()
        self.mid_pt = []
        self.end_points = []
        self.mask = []
        self.crack_tracks = {}
        self.cracks_stored_endpoints = {}
        self.crack_tracks = {}
        self.change_image()

    def update_selected_item(self,name):
        items = self.files_list.findItems(name, QtCore.Qt.MatchExactly)
        self.files_list.setCurrentItem(items[0])

    def change_image(self):
            w = self.segment_width_box_2.value()
            if self.track_color_box.currentText() == "R":
                color = (1,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,1,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,1)
            elif self.track_color_box.currentText() == "W":
                color = (1,1,1)
            self.update_selected_item(os.path.basename(self.image_names[self.n]))
            self.name = self.image_names[self.n]
            #self.image = cv2.imread(self.name)[:,:,::-1].astype(np.uint8)
            self.image = cv2.imread(self.name)
            self.original_image = self.image.copy()
            self.filename_label_2.setText(os.path.basename(self.name))

            im = self.original_image.astype(np.uint8)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.ImageScreen.setPixmap(scaled_pixmap)

            self.ann_name = os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json'
            if os.path.exists(self.ann_name):
                with open(self.ann_name) as f:
                    self.annotation = json.load(f)
                if 'annotations' in self.annotation.keys():
                    if 'crack_pixels' in self.annotation['annotations'].keys():
                        crack_pixels = self.annotation['annotations']['crack_pixels']
                        if crack_pixels != []:
                            mask = np.zeros((self.image.shape[0],self.image.shape[1]))
                            c = np.array(crack_pixels)
                            mask[list(c[:,0]),list(c[:,1])] = 1
                            # p = np.argwhere(mask==1)
                            self.image = (mark_boundaries(self.image/255, mask,
                                                                color=color, mode='inner', background_label=1)*255).astype(np.uint8)
                            
                            im = self.image.copy()
                            im = im.astype(np.uint8)
                            qimage = QImage(im, im.shape[1], im.shape[0], 
                                im.strides[0], QImage.Format_RGB888)
                            pixmap = QPixmap.fromImage(qimage)
                            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
                            self.ImageScreen.setPixmap(scaled_pixmap)
                    if 'box' in self.annotation['annotations'].keys():
                        for key in self.annotation['annotations']['box'].keys():
                            if self.annotation['annotations']['box'][key]['class'] == 0:
                                color = (0,0,255)
                            elif self.annotation['annotations']['box'][key]['class'] == 1:
                                color = (0,255,0)
                            else:
                                color = (255,0,0)
                            bb_pts = np.array(self.annotation['annotations']['box'][key]['bounding_box'])
                            cv2.line(self.image,(bb_pts[0,0],bb_pts[0,1]),(bb_pts[1,0],bb_pts[0,1]),color,5)
                            cv2.line(self.image,(bb_pts[0,0],bb_pts[0,1]),(bb_pts[0,0],bb_pts[1,1]),color,5)
                            cv2.line(self.image,(bb_pts[1,0],bb_pts[1,1]),(bb_pts[0,0],bb_pts[1,1]),color,5)
                            cv2.line(self.image,(bb_pts[1,0],bb_pts[1,1]),(bb_pts[1,0],bb_pts[0,1]),color,5)
                            im = self.image.astype(np.uint8)
                            qimage = QImage(im, im.shape[1], im.shape[0], 
                                im.strides[0], QImage.Format_RGB888)
                            pixmap = QPixmap.fromImage(qimage)
                            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
                            self.ImageScreen.setPixmap(scaled_pixmap)
                    else:
                        self.annotation['annotations']['box'] = {}
            else:
                self.annotation = {}
                self.annotation['image_name'] = self.name
                self.annotation['annotations'] = {}
                self.annotation["annotations"]["cracks end-points"] = []
                self.annotation["annotations"]["crack_pixels"] = []
                self.annotation["annotations"]['tracks'] = []
                self.annotation["annotations"]['box'] = {}  


    def next_image(self):
        try:
            self.mid_pt = []
            self.end_points = []
            self.mask = []
            self.crack_tracks = {}
            self.cracks_stored_endpoints = {}
            self.crack_tracks = {}
            self.n = self.n + 1
            self.change_image()
        except Exception as e:
            print(e)
            error()

    def previous_image(self):
        try:
            self.mid_pt = []
            self.end_points = []
            self.mask = []
            self.crack_tracks = {}
            self.cracks_stored_endpoints = {}
            self.crack_tracks = {}
            self.n = self.n - 1
            self.change_image()
        except Exception as e:
            print(e)
            error()
        
    def draw_box(self):
        self.image_size = self.select_image_size_2.value()
        self.bb_pts,_ = ct.tools.Draw().bounding_box(self.image[:,:,::-1],self.image_size)
        self.bb_pts = np.array(self.bb_pts,dtype = np.int32)
        self.saved = False
        if len(np.array(self.bb_pts))==2:
            cv2.line(self.image,(self.bb_pts[0,0],self.bb_pts[0,1]),(self.bb_pts[1,0],self.bb_pts[0,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[0,0],self.bb_pts[0,1]),(self.bb_pts[0,0],self.bb_pts[1,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[1,0],self.bb_pts[1,1]),(self.bb_pts[0,0],self.bb_pts[1,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[1,0],self.bb_pts[1,1]),(self.bb_pts[1,0],self.bb_pts[0,1]),(0,255,0),5)

            # self.image[self.bb_pts[0,0],self.bb_pts[1,0],:] = [0,255,0]
            # self.image[self.bb_pts[1,1],self.bb_pts[0,1],:] = [0,255,0]
            # self.image[self.bb_pts[1,1],self.bb_pts[1,0],:] = [0,255,0]
            im = self.image.astype(np.uint8)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.ImageScreen.setPixmap(scaled_pixmap)

    def save_box(self):
        class_ = self.ClassSpinBox.value()
        if self.saved == False:
            self.saved = True
            if len(self.bb_pts)>0:
                if len(np.fromiter(self.annotation['annotations']['box'].keys(),float))==0:
                    self.annotation['annotations']['box'][1] = {'bounding_box':self.bb_pts.tolist(),'class':class_}
                    json_file = json.dumps(self.annotation)
                    with open(self.ann_name, 'w') as f:        
                        f.write(json_file)   
                        print('saved')
                else:
                    self.annotation['annotations']['box'][int(np.max(np.fromiter(self.annotation['annotations']['box'].keys(),float))+1)] = {'bounding_box':self.bb_pts.tolist(),'class':class_}
                    with open(self.ann_name, 'w') as fp:
                        json.dump(self.annotation, fp)
                    print('saved')
            else:
                print('no box to save')
        
        self.change_image()

    def clear_boxes(self):
        self.annotation['annotations']['box'] = {}
        with open(self.ann_name, 'w') as fp:
            json.dump(self.annotation, fp)
        print('saved')
        self.change_image()

    def clear_segmentation(self):
        self.annotation["annotations"]["cracks end-points"] = []
        self.annotation["annotations"]["crack_pixels"] = []
        self.annotation["annotations"]['tracks'] = []
        with open(self.ann_name, 'w') as fp:
            json.dump(self.annotation, fp)
        print('saved')
        self.change_image()

    def annotation_full_screen(self):
        try:
            self.image_size = self.select_image_size.value()
            _,_ = ct.tools.Draw().bounding_box(self.image[:,:,::-1],self.image_size)
        except Exception as e:
            print(e)
            error()
################################################################################################################

    def select_end_points(self):
        try :
            self.image_size = self.select_image_size.value()
            ptss = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
            self.end_points = ptss
            self.points_pairs_list = [ptss[b*2:b*2+2] for b in range(len(ptss))]
            if len(self.points_pairs_list) == 2:
                self.update_image_crop_button.setStyleSheet("background-color : lightblue")
                self.middle_point_button.setStyleSheet("background-color : lightblue")
            else:
                self.update_image_crop_button.setStyleSheet("background-color : red")
                self.middle_point_button.setStyleSheet("background-color : red")
        except Exception as e:
            print(e)
            error()
            self.update_image_crop_button.setStyleSheet("background-color : red")
            self.middle_point_button.setStyleSheet("background-color : red")

    def update_image_crop(self):
        try :
            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()
            downsample_factor = self.downsample_factor_box.value()
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
            if self.end_points == []:
                self.select_end_points()
            self.pts = self.end_points
            black_crack = [0 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            if black_crack==1:
                func = np.min
            elif  black_crack==0:
                func = np.max
            self.image_crop,self.pts_crop = ct.tools.image_crop(self.original_image,self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
            self.image_crop_down = skimage.measure.block_reduce(self.image_crop, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
            self.pts_crop_down = [x / downsample_factor for x in self.pts_crop]
            self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
            self.pts_down = [x / downsample_factor for x in self.pts]
            gs_image = self.image_crop_down[:,:,color_channel].astype(np.uint8)
            gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[0][0]),int(self.pts_crop_down[0][1])),
                                radius = 2,color = (0,255,0),thickness = 2)
            gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[1][0]),int(self.pts_crop_down[1][1])),
                                radius = 2,color = (0,255,0),thickness = 2)
            qimage = QImage(gs_image.astype(dtype=np.uint8), gs_image.shape[1], gs_image.shape[0], 
                            gs_image.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.image_crop_down_display.width(), self.image_crop_down_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.image_crop_down_display.setPixmap(scaled_pixmap)
            self.x_size_show.display(self.image_crop_down.shape[1])
            self.y_size_show.display(self.image_crop_down.shape[0])
            self.update_os_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.update_os_button.setStyleSheet("background-color : red")

    def check_wavelet(self):
        try:
            size = self.wavelet_size_box.value()
            nOrientations = self.wavelet_norientations_box.value()
            design = "N"
            inflectionPoint = self.wavelet_inflection_point_box.value()
            mnOrder = self.wavelet_mnorder_box.value()
            splineOrder = 3
            overlapFactor = self.wavelet_overlap_factor_box.value()
            dcStdDev = self.wavelet_STD_box.value()
            directional = False
            window_size = self.wavelet_window_size_box.value()

            wavelet = ct.os.CheckWavelet(window_size = window_size, size = size, nOrientations = nOrientations, design = design, 
                            inflectionPoint = inflectionPoint, mnOrder = mnOrder, splineOrder = splineOrder,
                            overlapFactor = overlapFactor, dcStdDev = dcStdDev, directional = directional,
                            display_orientations=[0])[0,:,:]
            wavelet = wavelet - np.min(wavelet)
            wavelet = (wavelet*254/np.max(wavelet)).astype(dtype=np.int8)

            qimage = QImage(wavelet.astype(dtype=np.uint8), wavelet.shape[1], wavelet.shape[0], 
                            wavelet.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.wavelet_check_display.width(), self.wavelet_check_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.wavelet_check_display.setPixmap(scaled_pixmap)
        except Exception as e:
            print(e)
            error()

    def select_middle_point(self):
        try :
            self.image_size = self.select_image_size.value()
            downsample_factor = self.downsample_factor_box.value()
            mid_pt = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
            self.mid_pt = (int(mid_pt[0][0]/downsample_factor),int(mid_pt[0][1]/downsample_factor))
            self.middpoint_update_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.middpoint_update_button.setStyleSheet("background-color : red")

    def update_midpoint_image(self):
        try:
            self.image_size = self.select_image_size.value()
            downsample_factor = self.downsample_factor_box.value()
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
            d = int(self.wavelet_window_size_box.value()/2)
            if self.mid_pt == []:
                self.select_middle_point()
            try :
                mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                                int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
            except:
                black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
                if black_crack==1:
                    func = np.min
                elif  black_crack==-1:
                    func = np.max
                self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
                mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                                int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
            mid_image = mid_image[:,:,color_channel]
            qimage = QImage(mid_image.astype(dtype=np.uint8), mid_image.shape[1], mid_image.shape[0], 
                            mid_image.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.middlepoint_display.width(), self.middlepoint_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.middlepoint_display.setPixmap(scaled_pixmap)
        except Exception as e:
            print(e)
            error()

    def update_os(self):
        try:
            self.os_progress_bar.setValue(0)
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            size = self.wavelet_size_box.value()
            nOrientations = self.wavelet_norientations_box.value()
            design = "N"
            inflectionPoint = self.wavelet_inflection_point_box.value()
            mnOrder = self.wavelet_mnorder_box.value()
            splineOrder = 3
            overlapFactor = self.wavelet_overlap_factor_box.value()
            dcStdDev = self.wavelet_STD_box.value()
            directional = False
            self.osGFCost = ct.os.OrientationScoreTransform(self.image_crop_down[:,:,color_channel]/255*black_crack, size = size, 
                                            nOrientations = nOrientations, design = design, 
                                            inflectionPoint = inflectionPoint, mnOrder = mnOrder, 
                                            splineOrder = splineOrder, overlapFactor = overlapFactor, 
                                            dcStdDev = dcStdDev, directional = directional)
            self.os_progress_bar.setValue(100)
            self.update_cost_button.setStyleSheet("background-color : lightblue")
            self.show_os_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.update_cost_button.setStyleSheet("background-color : red")
            self.show_os_button.setStyleSheet("background-color : red")

    def show_os(self):
        import plotly.graph_objects as go
        import numpy as np
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
        shift = -30
        osGFCost_shift = np.roll(self.osGFCost, shift=shift,axis = 0)
        osGFCost_shift.shape
        downsample_factor = self.downsample_factor_box.value()
        downsample_rate_spatial = downsample_factor
        downsample_rate_angular = 1
        # angular_shift = int(1*osGFCost.shape[0])
        # osGFCosts = 
        values = osGFCost_shift[:int(self.osGFCost.shape[0]/2),:,:].real
        X, Y, Z = np.mgrid[:values.shape[0],:values.shape[1],:values.shape[2]]
   
        # image_gray_cropp_down = scipy.ndimage.zoom(self.image_crop[:,:,color_channel], 
        #                                         ((Y.shape[1])/self.image_crop.shape[0],
        #                                                             (Y.shape[2])/self.image_crop.shape[1]), order=3)
        yim = np.linspace(0,self.image_crop_down.shape[0],self.image_crop_down.shape[0])
        zim = np.linspace(0,self.image_crop_down.shape[1],self.image_crop_down.shape[1])


        yim,zim = np.meshgrid(yim,zim)
        xim = np.ones(yim.shape)*0

        a = self.osGFCost.shape[0]/2-1
        b = self.osGFCost.shape[1]
        c = self.osGFCost.shape[2]

        fig = go.Figure(data=go.Volume(
            x=X.flatten(),
            y=Y.flatten(),
            z=Z.flatten(),
            value=values.flatten(),
            isomin=np.min(values),
            isomax=np.max(values),
            opacity=1, # needs to be small to see through all surfaces
            opacityscale='min',
            colorscale='Hot',
            caps= dict(x_show=False, y_show=False, z_show=False, x_fill=1),

        ))

        fig.update_traces(lighting=dict(ambient = 0.4,diffuse = 0.9,fresnel = 0.8,roughness = 0.5,specular = 0.05),
                        selector=dict(type='volume'))


        fig.update_traces(surface=dict(count=5,fill = 1,pattern='all',show=True), selector=dict(type='volume'))


        r = self.image_crop.shape[0]/self.image_crop_down.shape[1]
        fig.update_layout(scene_aspectmode='manual',
                        scene_aspectratio=dict(x=0.5, y=r, z=1))

        fig.update_layout(scene_xaxis_showticklabels=False,
                        scene_yaxis_showticklabels=False,
                        scene_zaxis_showticklabels=False),
        fig.add_surface(x=xim, y=yim, z=zim, 
                        surfacecolor=self.image_crop_down[:,:,color_channel][:,:,0].T, 
                        colorscale='gray', 
                        showscale=False)

        fig.add_scatter3d(
                x=[0, 0, a, a, 0, 0, a, a, a, 0, 0, 0, 0, a, a, a],
                y=[0, b, b, 0, 0, 0, 0, b, b, b, b, 0, b, b, 0, 0],
                z=[0, 0, 0, 0, 0, c, c, c, 0, 0, c, c, c, c, c, 0],
            mode = 'lines',
            line=dict(
                color='black',
                width=2
            )
        )

        fig.update_layout(scene = dict(
                            xaxis = dict(showbackground=False),
                            yaxis = dict(showbackground=False),
                            zaxis = dict(showbackground=False)))
        fig.update_layout(scene = dict(
                            xaxis_title="θ",
                            yaxis_title='x1',
                            zaxis_title='x2'))



        fig.update_traces(showscale=True, selector=dict(type='volume'))
        fig.update_layout(margin_autoexpand=True)
        fig.update_layout(font=dict(size = 60))
        k = 4.5
        camera = dict(
            up=dict(x=1, y=0, z=0),
            center=dict(x=-0.15, y=0, z=0),
            eye=dict(x=0.085*k, y=0.23*k, z=0.2*k)
        )
        fig.update_layout(scene_camera=camera,title='default')

        fig.show()

    def update_cost(self):
        try:
            self.update_cost_bar.setValue(0)
            lambdaa = self.lambda_box.value()
            p = self.power_box.value()
            ksi = 1
            zeta = 1
            sigmas = self.sigmas_line_edit.text()
            sigmas = [float(i) for i in sigmas.split(sep = ',')]
            sigmas_ext = 1
            self.multiscalecostLIFExtReg = ct.os.MultiScaleVesselness(self.osGFCost.real,ksi,1,sigmas,"LIF",sigmas_ext = sigmas_ext)

            costmultiscale = ct.os.MultiScaleVesselnessFilter(self.multiscalecostLIFExtReg)
            self.costFunction = ct.os.CostFunction(costmultiscale,lambdaa = lambdaa, p = p)
            c00 = np.min(ct.os.Rescale(self.costFunction),axis = 0)
            self.update_cost_bar.setValue(100)
            c00 = c00 - np.min(c00)
            c00 = (c00*255/np.max(c00)).astype(dtype=np.uint8)
            qimage = QImage(c00.astype(dtype=np.uint8), c00.shape[1], c00.shape[0], 
                            c00.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.cost_display.width(), self.cost_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.cost_display.setPixmap(scaled_pixmap)
            self.midline_track_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.midline_track_button.setStyleSheet("background-color : red")

    def midline_tracking(self):
        try :
            self.tracking_bar.setValue(0)
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)

            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()
            g11 = self.g11_box.value()
            g22 = self.g22_box.value()
            g33 = self.g33_box.value()
            x_margin = self.x_margin_box.value()
            downsample_factor = self.downsample_factor_box.value()


            track_crop_down = ct.tracking.fast_marching(self.costFunction,self.pts_crop_down[0],self.pts_crop_down[1],g11=g11,g22=g22,g33=g33)
            track_crop_down[0] = track_crop_down[0]-0.5
            track_crop_down[1] = track_crop_down[1]-0.5
            track_crop = track_crop_down.copy()
            track_crop[0] = track_crop_down[0]*downsample_factor
            track_crop[1] = track_crop_down[1]*downsample_factor
            self.track_crop = track_crop
            track = ct.tools.track_crop_to_full(track_crop,self.pts[0],self.pts[1],y_margin,x_margin)
            self.track = track
            pts = np.array(track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, color, w)

            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.track_display.setPixmap(scaled_pixmap)
            self.tracking_bar.setValue(100)
            self.update_track_display_button.setStyleSheet("background-color : lightblue")
            self.track_full_screen_button.setStyleSheet("background-color : lightblue")
            self.edge_mask_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.update_track_display_button.setStyleSheet("background-color : red")
            self.track_full_screen_button.setStyleSheet("background-color : red")
            self.edge_mask_button.setStyleSheet("background-color : red")

    
    def update_track_display(self):
        try :
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)
            pts = np.array(self.track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, color, w)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.track_display.setPixmap(scaled_pixmap)
        except Exception as e:
            print(e)
            error()

    def track_full_screen(self):
        try :
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
                c = 'r'
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
                c = 'g'
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
                c = 'b'
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)
                c = 'w'

            im = self.image.astype(np.uint8)
            plt.imshow(im)
            plt.plot(self.track[0],self.track[1],color = c,linewidth=w)
            plt.show()
        except Exception as e:
            print(e)
            error()

    def edge_mask(self):
        try:
            if not self.track:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("No track defined")
                return
            window_half_size = int(self.edge_filter_size_box.value()/2)

            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()


            black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            self.edge_mask1, self.edge_mask2 = ct.segmentation.edge_masks(self.original_image[:,:,color_channel]*black_crack,np.array(self.track),window_half_size=window_half_size)

            self.edge_mask1_crop,pts_crop = ct.tools.image_crop(self.edge_mask1[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
            self.edge_mask2_crop,pts_crop = ct.tools.image_crop(self.edge_mask2[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)

            edge_mask1_crop = self.edge_mask1_crop - np.min(self.edge_mask1_crop)
            edge_mask1_crop = (edge_mask1_crop*255/np.max(edge_mask1_crop)).astype(dtype=np.uint8)

            qimage = QImage(edge_mask1_crop.astype(dtype=np.uint8), edge_mask1_crop.shape[1], edge_mask1_crop.shape[0], 
                            edge_mask1_crop.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.edge_map_display.width(), self.edge_map_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.edge_map_display.setPixmap(scaled_pixmap)
            self.edge_tracks_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.edge_tracks_button.setStyleSheet("background-color : red")

    def edge_tracking(self):
        try :
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()

            w = self.edge_track_width_box.value()
            if self.edge_track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.edge_track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.edge_track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.edge_track_color_box.currentText() == "W":
                color = (255,255,255)

            mu = self.mu_box.value()
            l = self.l_box.value()
            p = self.p_box.value()

            track_e1_crop, track_e2_crop = ct.segmentation.edges_tracking(self.image_crop[:,:,color_channel], self.pts_crop, 
                                                        self.edge_mask1_crop,self.edge_mask2_crop, mu = mu,l = l, p = p)
            track_e1_crop = track_e1_crop[::-1]
            track_e2_crop = track_e2_crop[::-1]

            track_e1_crop[0] = track_e1_crop[0] - 0.5
            track_e2_crop[0] = track_e2_crop[0] - 0.5

            track_e1_crop[1] = track_e1_crop[1] - 0.5
            track_e2_crop[1] = track_e2_crop[1] - 0.5

            self.track_e1 = ct.tools.track_crop_to_full(track_e1_crop,self.pts[0],self.pts[1],y_margin,x_margin)
            self.track_e2 = ct.tools.track_crop_to_full(track_e2_crop,self.pts[0],self.pts[1],y_margin,x_margin)


            pts1 = np.array(track_e1_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            pts2 = np.array(track_e2_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts1], False, color, w)
            im = cv2.polylines(im, [pts2], False, color, w)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.edge_tracks_display.width(), self.edge_tracks_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.edge_tracks_display.setPixmap(scaled_pixmap)
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
            self.save_current_segment_button.setStyleSheet("background-color : lightblue")
        except Exception as e:
            print(e)
            error()
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : reed")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
            self.save_current_segment_button.setStyleSheet("background-color : red")

    def edge_tracks_full_screen(self):
        try:
            w = self.edge_track_width_box.value()
            if self.edge_track_color_box.currentText() == "R":
                c = 'r'
            elif self.edge_track_color_box.currentText() == "G":
                c = 'g'
            elif self.edge_track_color_box.currentText() == "B":
                c = 'b'
            elif self.edge_track_color_box.currentText() == "W":
                c = 'w'

            im = self.image.astype(np.uint8)
            plt.imshow(im)
            plt.plot(self.track_e1[0],self.track_e1[1],color = c,linewidth=w)
            plt.plot(self.track_e2[0],self.track_e2[1],color = c,linewidth=w)
            plt.show()
        except Exception as e:
            print(e)
            error()

    def save_current_segment(self):
        try:
            edge_x = np.concatenate((self.track_e1[1][::-1],self.track_e2[1]))
            edge_y = np.concatenate((self.track_e1[0][::-1],self.track_e2[0]))

            mask_FM = ct.segmentation.create_mask(self.image,edge_y,edge_x)
            self.mask.append(mask_FM)
            track = [list(x) for x in self.track]
            self.cracks_stored_endpoints[len(self.cracks_stored_endpoints.keys())] = [self.pts[0].tolist(),self.pts[1].tolist()]
            self.crack_tracks[len(self.crack_tracks)] = track
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 255
            m = m.astype(dtype=np.uint8)
            qimage = QImage(m.astype(dtype=np.uint8), m.shape[1], m.shape[0], 
                            m.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.all_segments_display.width(), self.all_segments_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.all_segments_display.setPixmap(scaled_pixmap)

            pts1 = np.array(self.track_e1).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            pts2 = np.array(self.track_e2).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            im = cv2.polylines(im, [pts1], False, (0,255,0), 1)
            im = cv2.polylines(im, [pts2], False, (0,255,0), 1)
            self.image = im

            self.save_annotation()

        except Exception as e:
            print(e)
            error()

        # plt.imshow(m)
        # plt.plot(self.track_e1[0],self.track_e1[1],'r')
        # plt.plot(self.track_e2[0],self.track_e2[1],'r')
        # plt.show()

    def draw_segment(self):
        try:
            image_size = self.select_image_size.value()
            x,y = ct.tools.Draw().counturs(self.image[:,:,::-1],image_size)
            if len(x) == 0:
                return
            x = np.concatenate([x,np.array(x[0]).reshape(1)])
            y = np.concatenate([y,np.array(y[0]).reshape(1)])
            self.manuall_x = np.array(x)
            self.manuall_y = np.array(y)

            pts = np.array([x,y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, (0, 255, 0), 1)

            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.manual_segment_screen.width(), self.manual_segment_screen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.manual_segment_screen.setPixmap(scaled_pixmap)
        except Exception as e:
            print(e)
            error()


    def manual_segment_full_screen(self):
        try:
            pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            plt.imshow(im)
            plt.plot(self.manuall_x,self.manuall_y,'r',linewidth = 1)
            plt.show()
        except Exception as e:
            print(e)
            error()

    def save_manual_segment(self):
        try:
            mask_FM = ct.segmentation.create_mask(self.image,self.manuall_x,self.manuall_y)
            self.mask.append(mask_FM)
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 255
            m = m.astype(dtype=np.uint8)
            pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            im = cv2.polylines(im, [pts], False, (0,255,0), 1)
            self.image = im

            self.save_annotation()
        except Exception as e:
            print(e)
            error()

    def save_annotation(self):
        try:
            self.annotation["annotations"]["cracks end-points"] = self.cracks_stored_endpoints
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 1.0
            crack_pixels = np.argwhere(m==1.0)
            self.annotation["annotations"]["crack_pixels"] = crack_pixels.tolist()
            self.annotation["annotations"]['tracks'] = self.crack_tracks
            json_file = json.dumps(self.annotation)
            with open(os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json', 'w') as f:        
                f.write(json_file)
            self.change_image()

            self.update_image_crop_button.setStyleSheet("background-color : red")
            self.middle_point_button.setStyleSheet("background-color : red")
            self.middpoint_update_button.setStyleSheet("background-color : red")
            self.update_os_button.setStyleSheet("background-color : red")
            self.update_cost_button.setStyleSheet("background-color : red")
            self.midline_track_button.setStyleSheet("background-color : red")
            self.update_track_display_button.setStyleSheet("background-color : red")
            self.track_full_screen_button.setStyleSheet("background-color : red")
            self.edge_mask_button.setStyleSheet("background-color : red")
            self.edge_tracks_button.setStyleSheet("background-color : red")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
            self.save_current_segment_button.setStyleSheet("background-color : red")
        except Exception as e:
            print(e)
            error()

if __name__ == "__main__":
    import sys
    import time
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = CrackToolsApplication()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())